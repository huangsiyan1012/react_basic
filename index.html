<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Gesture Controlled Christmas Tree</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #05100e;
        font-family: "Arial", sans-serif;
      }
      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
      }
      #video-container {
        position: absolute;
        bottom: 20px;
        right: 20px;
        z-index: 2;
        width: 160px;
        height: 120px;
        border-radius: 10px;
        overflow: hidden;
        border: 2px solid #d4af37;
        box-shadow: 0 0 15px rgba(212, 175, 55, 0.5);
        transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
      }
      video {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      #ui-layer {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 3;
        color: #d4af37;
        text-shadow: 0 0 5px rgba(212, 175, 55, 0.8);
        pointer-events: none;
      }
      h1 {
        margin: 0;
        font-weight: 300;
        letter-spacing: 2px;
      }
      p {
        font-size: 14px;
        opacity: 0.8;
      }
      .status {
        font-weight: bold;
        color: #ff3333;
      }
      #upload-btn {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid #d4af37;
        color: #d4af37;
        padding: 8px 15px;
        cursor: pointer;
        margin-top: 10px;
        transition: all 0.3s;
      }
      #upload-btn:hover {
        background: #d4af37;
        color: #000;
        box-shadow: 0 0 15px #d4af37;
      }
      #file-input {
        display: none;
      }
      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #d4af37;
        z-index: 10;
        font-size: 24px;
        transition: opacity 0.5s;
      }
    </style>
    <!-- Import Modules via Import Map -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <!-- MediaPipe Libraries -->
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>
    <div id="loading">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹ä¸ 3D å¼•æ“...</div>

    <div id="ui-layer">
      <h1>MERRY CHRISTMAS</h1>
      <p>çŠ¶æ€: <span id="status-text" class="status">åˆæ‹¢æ€ (Tree)</span></p>
      <p>æ“ä½œæŒ‡å—: âœŠ åˆæ‹¢ | ğŸ– æ•£å¼€ | ğŸ‘Œ(æ•£å¼€æ—¶) æŠ“å–ç…§ç‰‡</p>
      <input type="file" id="file-input" multiple accept="image/*" />
      <button
        id="upload-btn"
        onclick="document.getElementById('file-input').click()"
      >
        ä¸Šä¼ ç…§ç‰‡ç”Ÿæˆäº‘
      </button>
    </div>

    <div id="video-container">
      <video id="input_video"></video>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
      import * as THREE from "three";
      import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
      import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
      import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";

      // --- Configuration ---
      const CONFIG = {
        colors: {
          green: 0x2e4a3d, // Matte Green
          gold: 0xd4af37, // Metallic Gold
          red: 0x8a1c1c, // Christmas Red
          white: 0xffffff,
        },
        particleCount: 400,
        treeHeight: 30,
        treeRadius: 12,
        scatterRadius: 40,
      };

      // --- State Management ---
      const STATE = {
        mode: "tree", // 'tree', 'scatter', 'zoom'
        handOpen: false,
        handClosed: false,
        pinching: false,
        targetRotationX: 0,
        targetRotationY: 0,
        zoomTargetIndex: -1,
      };

      // --- Three.js Variables ---
      let scene, camera, renderer, composer;
      let particles = [];
      let photoTextures = [];
      const dummy = new THREE.Object3D();
      const geometryTypes = ["sphere", "box", "cylinder", "photo"];

      // --- Initialization ---
      init();
      animate();

      function init() {
        // 1. Scene & Camera
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x05100e, 0.02);

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 50);

        // 2. Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document
          .getElementById("canvas-container")
          .appendChild(renderer.domElement);

        // 3. Post-processing (Bloom)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(
          new THREE.Vector2(window.innerWidth, window.innerHeight),
          1.5,
          0.4,
          0.85
        );
        bloomPass.threshold = 0.2;
        bloomPass.strength = 1.2; // Glow intensity
        bloomPass.radius = 0.5;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 4. Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(CONFIG.colors.gold, 2, 100);
        pointLight.position.set(0, 10, 10);
        scene.add(pointLight);

        // 5. Create Default Particles
        createParticles();

        // 6. Event Listeners
        window.addEventListener("resize", onWindowResize);
        document
          .getElementById("file-input")
          .addEventListener("change", handleUpload);
      }

      function createParticles() {
        // Clear existing
        particles.forEach((p) => scene.remove(p.mesh));
        particles = [];

        const matGreen = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.green,
          roughness: 0.8,
          metalness: 0.1,
        });
        const matGold = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.gold,
          roughness: 0.2,
          metalness: 0.9,
          emissive: 0x221100,
        });
        const matRed = new THREE.MeshStandardMaterial({
          color: CONFIG.colors.red,
          roughness: 0.4,
          metalness: 0.3,
        });

        const geoSphere = new THREE.SphereGeometry(0.5, 16, 16);
        const geoBox = new THREE.BoxGeometry(0.8, 0.8, 0.8);
        const geoCyl = new THREE.CylinderGeometry(0.2, 0.2, 1.5, 8); // Candy stick
        const geoPlane = new THREE.PlaneGeometry(2, 2);

        for (let i = 0; i < CONFIG.particleCount; i++) {
          let type =
            geometryTypes[
              Math.floor(Math.random() * (photoTextures.length > 0 ? 4 : 3))
            ];
          let mesh, material;

          if (type === "photo" && photoTextures.length > 0) {
            const tex =
              photoTextures[Math.floor(Math.random() * photoTextures.length)];
            material = new THREE.MeshBasicMaterial({
              map: tex,
              side: THREE.DoubleSide,
            });
            mesh = new THREE.Mesh(geoPlane, material);
          } else {
            const rand = Math.random();
            material = rand > 0.6 ? matGold : rand > 0.3 ? matRed : matGreen;
            if (type === "cylinder") material = rand > 0.5 ? matRed : matGold; // Candy sticks

            if (type === "sphere") mesh = new THREE.Mesh(geoSphere, material);
            else if (type === "box") mesh = new THREE.Mesh(geoBox, material);
            else mesh = new THREE.Mesh(geoCyl, material);
          }

          // Initial Position (Tree Shape)
          const treePos = calculateTreePosition(i, CONFIG.particleCount);

          // Scatter Position
          const scatterPos = new THREE.Vector3(
            (Math.random() - 0.5) * CONFIG.scatterRadius * 2,
            (Math.random() - 0.5) * CONFIG.scatterRadius * 2,
            (Math.random() - 0.5) * CONFIG.scatterRadius * 1.5
          );

          mesh.position.copy(treePos);
          mesh.rotation.set(
            Math.random() * Math.PI,
            Math.random() * Math.PI,
            0
          );

          scene.add(mesh);

          particles.push({
            mesh: mesh,
            treePos: treePos,
            scatterPos: scatterPos,
            velocity: new THREE.Vector3(),
            isPhoto:
              type === "photo" ||
              (photoTextures.length > 0 && Math.random() < 0.1), // Mark some as interactive
          });
        }
      }

      function calculateTreePosition(index, total) {
        // Spiral Cone Algorithm
        const ratio = index / total;
        const h = CONFIG.treeHeight * ratio - CONFIG.treeHeight / 2;
        const r = CONFIG.treeRadius * (1 - ratio);
        const angle = index * 137.5 * (Math.PI / 180); // Golden angle

        const x = r * Math.cos(angle);
        const z = r * Math.sin(angle);
        return new THREE.Vector3(x, h, z);
      }

      function handleUpload(event) {
        const files = event.target.files;
        if (!files.length) return;

        const loader = new THREE.TextureLoader();
        photoTextures = [];

        Array.from(files).forEach((file) => {
          const url = URL.createObjectURL(file);
          loader.load(url, (tex) => {
            tex.colorSpace = THREE.SRGBColorSpace;
            photoTextures.push(tex);
            // Re-create particles once loaded
            if (photoTextures.length === files.length) createParticles();
          });
        });
      }

      // --- Animation Loop ---
      function animate() {
        requestAnimationFrame(animate);

        // Smooth Logic Transition
        const dt = 0.05; // Interpolation factor

        particles.forEach((p, i) => {
          let target;

          if (STATE.mode === "tree") {
            target = p.treePos;
            p.mesh.lookAt(0, p.mesh.position.y, 0); // Face outward slightly
          } else if (STATE.mode === "scatter") {
            target = p.scatterPos;
            // Floating effect
            p.mesh.rotation.x += 0.01;
            p.mesh.rotation.y += 0.01;
          } else if (STATE.mode === "zoom") {
            if (i === STATE.zoomTargetIndex) {
              // Brings selected photo to front center
              target = new THREE.Vector3(0, 0, 15);
              p.mesh.lookAt(camera.position);
              // Scale up
              p.mesh.scale.lerp(new THREE.Vector3(5, 5, 5), dt);
            } else {
              // Push others back
              target = p.scatterPos.clone().multiplyScalar(1.5);
              p.mesh.scale.lerp(new THREE.Vector3(1, 1, 1), dt);
            }
          }

          // Apply Movement
          if (target) {
            p.mesh.position.lerp(target, dt);
          }
        });

        // Camera Rotation based on Hand (only in scatter mode)
        if (STATE.mode === "scatter") {
          const rotX = STATE.targetRotationY * 0.5; // Hand X moves Camera Y
          const rotY = STATE.targetRotationX * 0.5;
          scene.rotation.y += (rotX - scene.rotation.y) * 0.05;
          scene.rotation.x += (rotY - scene.rotation.x) * 0.05;
        } else {
          // Auto rotate tree slowly
          if (STATE.mode === "tree") scene.rotation.y += 0.002;
          scene.rotation.x *= 0.9; // Reset tilt
        }

        composer.render();
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
      }

      // --- MediaPipe Hand Tracking ---
      const videoElement = document.getElementById("input_video");
      const statusText = document.getElementById("status-text");

      function onResults(results) {
        document.getElementById("loading").style.display = "none";

        if (
          results.multiHandLandmarks &&
          results.multiHandLandmarks.length > 0
        ) {
          const landmarks = results.multiHandLandmarks[0];

          // 1. Detect Open/Closed Hand
          // Simple algorithm: Check if finger tips are above finger PIP joints (relative to palm)
          // Or easier: Distance of tips from wrist
          const wrist = landmarks[0];
          const tips = [8, 12, 16, 20]; // Index, Middle, Ring, Pinky
          let extendedFingers = 0;

          tips.forEach((idx) => {
            const tip = landmarks[idx];
            const pip = landmarks[idx - 2];
            // Very simple check: distance from wrist.
            // Better: Check vector dot product, but for simple UI:
            const dTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
            const dPip = Math.hypot(pip.x - wrist.x, pip.y - wrist.y);
            if (dTip > dPip * 1.2) extendedFingers++;
          });

          const isFist = extendedFingers === 0;
          const isOpen = extendedFingers >= 4;

          // 2. Pinch Detection (Thumb tip 4 and Index tip 8)
          const thumbTip = landmarks[4];
          const indexTip = landmarks[8];
          const pinchDist = Math.hypot(
            thumbTip.x - indexTip.x,
            thumbTip.y - indexTip.y
          );
          const isPinching = pinchDist < 0.05;

          // 3. State Machine Transition
          if (isFist) {
            STATE.mode = "tree";
            statusText.innerText = "åˆæ‹¢æ€ (Tree) ğŸ„";
            statusText.style.color = CONFIG.colors.green;
            STATE.zoomTargetIndex = -1;
          } else if (isOpen) {
            STATE.mode = "scatter";
            statusText.innerText = "æ•£å¼€æ€ (Scatter) âœ¨";
            statusText.style.color = CONFIG.colors.gold;
            STATE.zoomTargetIndex = -1;
          }

          // 4. Interaction in Scatter Mode
          if (STATE.mode === "scatter" || STATE.mode === "zoom") {
            // Rotation (Map Hand Center X/Y to Scene Rotation)
            // MediaPipe coords: x [0,1], y [0,1]
            STATE.targetRotationX = (landmarks[9].y - 0.5) * 2; // Middle finger MCP
            STATE.targetRotationY = (landmarks[9].x - 0.5) * 2;

            // Pinch to Zoom Photo
            if (isPinching && STATE.mode === "scatter") {
              // Find a random photo to zoom or closest one (simulated)
              STATE.mode = "zoom";
              // Pick a random particle that is a photo if we haven't picked one
              if (STATE.zoomTargetIndex === -1) {
                const photoIndices = particles
                  .map((p, i) => (p.isPhoto ? i : -1))
                  .filter((i) => i !== -1);
                if (photoIndices.length > 0) {
                  STATE.zoomTargetIndex =
                    photoIndices[
                      Math.floor(Math.random() * photoIndices.length)
                    ];
                } else {
                  STATE.zoomTargetIndex = Math.floor(
                    Math.random() * particles.length
                  );
                }
              }
              statusText.innerText = "ç…§ç‰‡æ”¾å¤§æ€ (Zoom) ğŸ“·";
              statusText.style.color = "#FFF";
            }
          }
        }
      }

      const hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        },
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      hands.onResults(onResults);

      const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 320,
        height: 240,
      });
      cameraUtils.start();
    </script>
  </body>
</html>
